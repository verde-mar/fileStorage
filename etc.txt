if (success == 0) {
        /* Rimuove l'elemento anche dalla coda FIFO */
        int succ_fifo = remove(file_path); 
        CHECK_OPERATION(succ_fifo == -1, 
            fprintf(stderr, "Errore nell'eliminazione di un elemento nella coda FIFO.\n"); 
                return -1);
    }

if (success == 0) {
            /* Aggiunge l'elemento in coda alla lista FIFO */
            int succ_fifo = add_fifo(file_path); 
            CHECK_OPERATION(succ_fifo == -1, 
                fprintf(stderr, "Errore nell'inserimento di un elemento nella coda FIFO.\n"); 
                    return -1);
        }




int add(list_t **lista_trabocco, char* file_path, int flags){
    CHECK_OPERATION(file_path == NULL || (*lista_trabocco) == NULL,
        fprintf(stderr, "Parametri non validi.\n");
            return -1);
   
        /* Crea il nodo da aggiungere */
        node *curr = (node*)malloc(sizeof(node));
        CHECK_OPERATION(curr == NULL,
            fprintf(stderr, "Allocazione non andata a buon fine.\n");
                return -1);
        curr->path = malloc(sizeof(char)*(strlen(file_path)+1));
        strcpy((char*)curr->path, file_path);
        int m_init = pthread_mutex_init(curr->mutex, NULL);
        CHECK_OPERATION(m_init =
int add(list_t **lista_trabocco, char* file_path, int flags){
    CHECK_OPERATION(file_path == NULL || (*lista_trabocco) == NULL,
        fprintf(stderr, "Parametri non validi.\n");
            return -1);
   
        /* Crea il nodo da aggiungere */
        node *curr = (node*)malloc(sizeof(node));
        CHECK_OPERATION(curr == NULL,
            fprintf(stderr, "Allocazione non andata a buon fine.\n");
                return -1);
        curr->path = malloc(sizeof(char)*(strlen(file_path)+1));
        strcpy((char*)curr->path, file_path);
        int m_init = pthread_mutex_init(curr->mutex, NULL);
        CHECK_OPERATION(m_init == -1,
            fprintf(stderr, "Errore nella inizializzazione della mutex.\n");
                return -1);
        curr->open = 0;
        curr->buffer = NULL;

        pthread_mutex_lock((*lista_trabocco)->mutex);

        /* Aggiunge il nodo in testa alla lista di trabocco*/
        curr->next = (*lista_trabocco)->head; 
        (*lista_trabocco)->head = curr;

        if(flags == 4){
            /* Setta la mutex */
            int err_set = set_mutex(curr);
            CHECK_OPERATION(err_set==-1,
                fprintf(stderr, "Errore nel setaggio della mutex");
                    return -1);
        }

        pthread_mutex_unlock((*lista_trabocco)->mutex);

    return 0;
}

node* delete(list_t **lista_trabocco, char* file_path){
    CHECK_OPERATION(!*lista_trabocco || !file_path,
        fprintf(stderr, "Parametri non validi.\n");
            return -1);

    node* curr, *prev;
    curr = (*lista_trabocco)->head;
    if (strcmp(curr->path, file_path) == 0){

        pthread_mutex_lock((*lista_trabocco)->mutex);
        (*lista_trabocco)->head = curr->next; 
        pthread_mutex_unlock((*lista_trabocco)->mutex);
        
        return curr;
    }

    prev = curr;
    curr = curr->next;
    while (curr != NULL) {
        if (strcmp(curr->path, file_path) == 0){

            pthread_mutex_lock((*lista_trabocco)->mutex);
            prev->next = curr->next; 
            pthread_mutex_unlock((*lista_trabocco)->mutex);

            return curr;
        }
        prev = curr;
        curr = curr->next;
    }

    return NULL;
}

node* look_for_node(char* file_path){
    CHECK_OPERATION(file_path == NULL, 
        fprintf(stderr, "Parametro non valido.\n");
            return -1);

    int hash = hash_function(file_path); //TODO:CREA
    node* curr;
    //TODO: metti in lock da qui
    for (curr=table->queue[hash]; curr != NULL; curr=curr->next)
        if (strcmp(curr->path, file_path) == 0)
            return(curr);

    return NULL;
}


int del_req(lista_richieste **queue){
    /* Rimuove ogni elemento della coda */
    request *tmp = NULL;
    while ((*queue)->head) {
        tmp = (*queue)->head;
        (*queue)->head = ((*queue)->head)->next;

        free(tmp->request);
        free(tmp);
    }
    
    /* Distrugge la lock di ciascun nodo */
    PTHREAD_DESTROY_LOCK((*queue)->mutex);
    free((*queue)->mutex);
    /* Distrugge la variabile di condizione di ciascun nodo */
    PTHREAD_DESTROY_COND((*queue)->cond);
    free((*queue)->cond);
    /* Libera la memoria occupata dalla lista di trabocco */
    free((*queue));

    return 0;
}


int caller_open(const char* pathname){
    int err;
    if(is_directory(pathname)){
        DIR *dir = opendir(pathname);
        CHECK_OPERATION(dir == NULL, fprintf(stderr, "Errore sulla opendir.\n"); return -1;);
        
        struct dirent *file;
        while((errno=0, file = readdir(dir))!=NULL && pathname != NULL){
            int len = strlen(pathname) + strlen(file->d_name) + strlen("/") + 1;
            const char *path = malloc(sizeof(char)*len);
            path = strcpy((char*)path, pathname);
            path = strcat((char*)path, "/");
            path = strcat((char*)path, file->d_name);

            if(strcmp(file->d_name, "..")!=0 && strcmp(file->d_name, ".")!=0){
                if(is_regular_file(path)){
                    err = openFile(path, O_CREATE | O_LOCK);
                    CHECK_OPERATION(err == -1, fprintf(stderr, "Errore nella chiamata a openFile.\n"); 
                        free((char*)path);
                            int check = closedir(dir);
                                CHECK_OPERATION(check == -1, fprintf(stderr, "Errore nella closedir.\n"); return -1);
                                    return -1;);
                } else if(is_directory(path)){
                    int result = caller_open(path);
                    CHECK_OPERATION(result == -1, fprintf(stderr, "Errore nella caller.\n"); 
                        free((char*)path);
                            int check = closedir(dir);
                                CHECK_OPERATION(check == -1, fprintf(stderr, "Errore nella closedir.\n"); return -1);
                                    return -1;);
                }
            }
            free((char*)path);
        }
        int check = closedir(dir);
        CHECK_OPERATION(check == -1, fprintf(stderr, " errore nella closedir.\n"); return -1);
    } else if(is_regular_file(pathname)){
        /* Gestisce la richiesta */
        err = openFile(pathname, O_CREATE | O_LOCK);
        CHECK_OPERATION(err == -1, fprintf(stderr, " errore nella chiamata a openFile(pathname).\n"); return -1;);
    }
    return 0;
}

int caller_write(const char* pathname, const char *dirname){
    int err;
    if(is_directory(pathname)){
        DIR *dir = opendir(pathname);
        CHECK_OPERATION(dir == NULL, fprintf(stderr, "Errore sulla opendir.\n"); return -1;);
        
        struct dirent *file;
        while((errno=0, file = readdir(dir))!=NULL && pathname != NULL){
            int len = strlen(pathname) + strlen(file->d_name) + strlen("/") + 1;
            const char *path = malloc(sizeof(char)*len);
            path = strcpy((char*)path, pathname);
            path = strcat((char*)path, "/");
            path = strcat((char*)path, file->d_name);

            if(strcmp(file->d_name, "..")!=0 && strcmp(file->d_name, ".")!=0){
                if(is_regular_file(path)){
                    err = writeFile(path, dirname);
                    CHECK_OPERATION(err == -1, fprintf(stderr, "Errore nella chiamata a writeFile.\n"); 
                        free((char*)path);
                            int check = closedir(dir);
                                CHECK_OPERATION(check == -1, fprintf(stderr, "Errore nella closedir.\n"); return -1);
                                    return -1;);
                } else if(is_directory(path)){
                    int result = caller_open(path);
                    CHECK_OPERATION(result == -1, fprintf(stderr, "Errore nella caller.\n"); 
                        free((char*)path);
                            int check = closedir(dir);
                                CHECK_OPERATION(check == -1, fprintf(stderr, "Errore nella closedir.\n"); return -1);
                                    return -1;);
                }
            }
            free((char*)path);
        }
        int check = closedir(dir);
        CHECK_OPERATION(check == -1, fprintf(stderr, "Errore nella closedir.\n"); return -1);
    } else if(is_regular_file(pathname)){
        /* Gestisce la richiesta */
        err = writeFile(pathname, dirname);
        CHECK_OPERATION(err == -1, fprintf(stderr, "Errore nella chiamata a writeFile.\n"); return -1;);
    }
    return 0;
}
push_queue((char*)argv[1], &(pool->pending_requests));
    push_queue((char*)argv[2], &(pool->pending_requests)); 


int deletes(list_t **lista_trabocco, char* file_path, node** just_deleted, int fd){
    CHECK_OPERATION(*lista_trabocco==NULL,
        fprintf(stderr, "Parametri non validi.\n");
            return -1);

    PTHREAD_LOCK(fifo_queue->mutex);
    
    PTHREAD_LOCK((*lista_trabocco)->mutex);
    
    int remover = del(file_path);
    CHECK_OPERATION(remover == -1, return -1);
    node* curr; /* Puntatore al nodo corrente */
    node *prev; /* Puntatore al nodo precedente */
    if ((*lista_trabocco)->head == NULL) /* Lista vuota */
        return 0;
    
    curr = *head_ptr;
    if (strcmp(curr->path, file_path) == 0) { /* Cancellazione del primo nodo */
        (*lista_trabocco)->head = curr->next; /* Aggiorna il puntatore alla testa */
        if((*just_deleted) == NULL) {
            PTHREAD_DESTROY_LOCK(curr->mutex);
            PTHREAD_DESTROY_COND(curr->locked); 
            free(curr->locked);
            free(curr->mutex);
            if(curr->buffer)
                free(curr->buffer); 
            free((char*)curr->path);
            free(curr);
            
        } else {
            *just_deleted = curr;
        }
        return 0;
    }

    /* Scansione della lista a partire dal secondo nodo */
    previous = current;
    current = current->next;
    while (current != NULL) {
        if (strcmp(curr->path, file_path) == 0) {
            if(curr->fd_c == fd){
                previous->next = current->next; 
                if((*just_deleted) == NULL) {
                    PTHREAD_DESTROY_LOCK(curr->mutex);
                    PTHREAD_DESTROY_COND(curr->locked); 
                    free(curr->locked);
                    free(curr->mutex);
                    if(curr->buffer)
                        free(curr->buffer); 
                    free((char*)curr->path);
                    free(curr);
                    
                } else {
                    *just_deleted = curr;
                }
                PTHREAD_UNLOCK((*lista_trabocco)->mutex);
                PTHREAD_UNLOCK(fifo_queue->mutex);
                return 0;
            } 
            /* Non e' stata acquisita la lock */
            else if(curr->fd_c != fd){
                PTHREAD_UNLOCK((*lista_trabocco)->mutex);
                PTHREAD_UNLOCK(fifo_queue->mutex);

                return 202;
            }
        }
        prev = curr;
        curr = curr->next;
    }
    return -1;
}